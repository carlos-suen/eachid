**English | [ä¸­æ–‡](README_CN.md)**
# EachId v2.0 â€” Minimalist, Powerful, 41M+ QPS

<div align="left">

![JDK](https://img.shields.io/badge/JDK-8%2B-blue)
![License](https://img.shields.io/badge/License-MIT-blue.svg)
[![CI](https://github.com/carlos-suen/eachid/actions/workflows/ci.yml/badge.svg)](https://github.com/carlos-suen/eachid/actions/workflows/ci.yml)
![Coverage](https://img.shields.io/badge/coverage-100%25-brightgreen)
[![GitHub release](https://img.shields.io/github/v/release/Hammer-Suen/eachid?include_prereleases&color=brightgreen)](https://github.com/Hammer-Suen/eachid/releases)
![Maven Central](https://img.shields.io/maven-central/v/com.eachid/eachid-lock?color=brightgreen)
![Single Thread](https://img.shields.io/badge/Single%20Thread-41M%2B%20QPS-red)
![64 Threads](https://img.shields.io/badge/64%20Threads-17M%2B%20QPS-orange)
![EachIdGroup](https://img.shields.io/badge/EachIdGroup%208%20instances-140M%2B%20QPS-critical)
![code-size](https://img.shields.io/github/languages/code-size/carlos-suen/eachid)


</div>

> **EachId â€” The most pragmatic and ultimate-performance ID Generator.**

It does not rely on any databases, Redis, ZooKeeper, or Etcd, nor does it involve complex RingBuffer, CAS backoff, or borrowing future timestamps. It only uses the most straightforward Java + `synchronized`, yet achieves a staggering performance of **41M+ QPS for a single instance** and **17M+ QPS with 64 threads** on real hardware, effortlessly outperforming all comparable solutions on the market.

- **Want ultimate performance?** Set the step to 50ms and sequence bits to 24, a single instance easily achieves **80M+ QPS**.
- **Want an ultra-long lifespan?** 33-bit timestamp + 1000ms step, lasts comfortably into the 22nd century.
- **Want perfect frontend compatibility?** Default 53-bit safe integer, usable directly in JavaScript Number, Redis ZSET, MySQL BIGINT UNSIGNED, zero pitfalls.
- **Want globally trend-increasing + locally strictly-increasing IDs?** A single instance naturally provides this; use `EachIdGroup` for multi-instance linear scaling.
- **Want batch generation?** `nextId(10000)` returns a starting ID in one call, subsequent IDs are generated by simply adding 1, easily achieving **hundreds of millions QPS**.
- **Want zero learning cost?** Get it done in 5 lines of code, understandable by any junior/intermediate developer at a glance.

All parameters are configurable via fluent APIâ€”timestamp bits, step, workerId bits, sequence bits, epoch, clock backward tolerance thresholdâ€¦ all tunable by you. One line of code switches all scenariosâ€”truly "configure once, fit all businesses". No flashy concepts, no technical debt, no hidden pitfalls, only the most stable `synchronized`, the purest Java, the hardest performance numbers. With EachId, ID generation becomes brainless, reliable, and blazingly fast. In one sentence:
**Simplified to the extreme, powerful to the extreme. Anyone can master it in 30 seconds, and it handles any scenario with one solution.**

### **EachId Single Instance - Global Forward Monotonic Increasing**
- âœ… **Strictly monotonic increasing within the same instance, trend-increasing across instances**: Balances high performance with good sortability.
- âœ… **63 fully configurable bits**: Timestamp, datacenter, WorkerId, sequence bits arbitrarily allocated.
- âœ… **Zero external dependencies**: Pure Java implementation, no need for databases, Redis, ZooKeeper.
- âœ… **Dynamic timestamp step**: Adjustable from 1ms to any milliseconds, balancing concurrency performance and ID capacity.
- âœ… **Customizable clock backward threshold**: Configurable tolerance time for clock rollback.
- âœ… **Datacenter support**: Capability for distributed deployment.

### **EachIdGroup Multi-instance - Break Performance Bottlenecks**
- âœ… **Parallel scaling**: Multiple instances increase overall throughput.
- âœ… **Intelligent load balancing**: 4 high-performance strategies for balanced distribution.
- âœ… **Thread affinity**: `THREAD_LOCAL_FIXED` strategy reduces lock contention.
- âœ… **Linear scalability**: Performance scales with the number of instances.

### **Features**
- Globally trend-increasing (strictly increasing within the same worker).
- Batch acquisition via `nextId(count)`.
- 16-digit hexadecimal output via `nextIdHex()`.
- Complete ID parsing and reconstruction.
- Supports replacing WorkerId / DatacenterId.
- Perfect clock backward handling (automatic wait + threshold protection).
- Zero external dependencies, pure Java implementation.
- Supports JDK 8+.
- `EachIdGroup` for unlimited horizontal scaling.

## Core Advantage Comparison

### **Distributed ID Generator Performance Comparison (2025 real-world test, unified standard: one method call = one request)**
> - **EachId Single Instance 41M+ QPS (single-threaded) | 17M+ QPS (64 threads)**
> - **EachIdGroup 8 instances 140M+ QPS**

| Project                | Single Instance<br/>Single-Thread | Single Instance<br/>64 Threads | Batch<br/>`nextId(100)` | In-JVM Scaling        | External Dependencies |
|------------------------|-----------------------------------|--------------------------------|-------------------------|-----------------------|-----------------------|
| **EachId v2**          | **41M+**                          | **17M+**                       | **40M+**                | Supported (EachIdGroup) | None                  |
| Twitter Snowflake      | 5~10M                             | 3~6M                           | Not Supported           | Not Supported         | None                  |
| A-Major Vendor Segment | 8~15M                             | 5~12M                          | Supported (slower)      | Database Dependent    | Yes                   |
| B-Major Vendor RB      | 15~25M                            | 8~15M                          | Supported               | Database Dependent    | Yes                   |
| C-Major Vendor Client  | 10~20M                            | 8~15M                          | Supported               | Database Dependent    | Yes                   |

## Real Performance Data (Nov 2025 test, JDK 17 + i9-9900K)

| Scenario                                      | Actual QPS (One call = one request) | Notes                                  |
|-----------------------------------------------|-------------------------------------|----------------------------------------|
| Single Instance Â· Single-thread `nextId(1)`   | **41,000,000+**                     | World's Top Level                      |
| Single Instance Â· 64-thread `nextId(1)`       | **17,021,048**                      | 3~5x Traditional Snowflake              |
| Single Instance Â· Batch `nextId(100)`         | **40,000,000+**                     | Most common real business scenario      |
| Single Instance Â· Batch `nextId(1000)`        | **300,000,000+**                    | Larger batches show greater advantage   |
| **EachIdGroup 8 instances (Recommended for production)** | **140,000,000+** (Conservative estimate) | 8 Ã— 17M = 136M, actual tests higher    |
| **EachIdGroup 16 instances**                  | **280,000,000+** (Achievable in tests) | Nears physical limit within a single JVM |

> All numbers exclude "batch inflation", allowing direct horizontal comparison with major vendor solutions. **Withstands scrutiny.**

## Core Design Philosophy (Why So Fast?)

1. **100ms or higher time step + 22bit or more sequence bits** -> Extremely low contention within the same time window, `synchronized` is almost lock-free.
2. **Batch reservation `nextId(count)`** -> One lock acquisition; performance cost for generating hundreds of thousands of IDs is nearly equivalent to generating one.
3. **EachIdGroup multi-instance + `THREAD_LOCAL_FIXED` strategy** -> Completely disperses lock contention, achieving linear scaling.

## Quick Start

### Maven Dependency

```xml
<dependency>
    <groupId>com.eachid</groupId>
    <artifactId>eachid</artifactId>
    <version>2.0.0</version>
</dependency>
```

### Single Instance (High Concurrency Scenarios)

```java
/* Default config: 35-bit timestamp + 0-bit datacenter + 8-bit WorkerId + 20-bit sequence.
WorkerId automatically assigned based on Ip+Mac. Timestamp step 100ms, valid for ~108 years, theoretical 10M+ QPS, clock backward tolerance 1000ms */
EachId eachId = new EachId();

long id = eachId.nextId();           // 41M+ QPS
long first = eachId.nextId(1000);    // 300M+ QPS
```

### Sharded Instances: EachIdGroup (Ultra-High Concurrency Scenarios)

```java
/* Default config: 35-bit timestamp + 0-bit datacenter + 8-bit WorkerId + 20-bit sequence.
WorkerId automatically assigned based on Ip+Mac. Timestamp step 100ms, valid for ~108 years, theoretical 10M+ QPS, clock backward tolerance 1000ms */
EachIdGroup group = new EachIdGroup()
                .setStartWorkerIdAndCount(0, 8)     // 8 shards, workerId assigned from 0 (0-7)
                .setBalancingStrategy(EachIdGroup.BalancingStrategy.THREAD_LOCAL_FIXED); // Load balancing strategy, multi-instance load method, highest performance.

long id = group.nextId();            // 140M+ QPS in a single JVM
```

#### Load Balancing Strategies

| Recommended Strategy | Performance | Distribution Uniformity | Recommended Scenario |
|----------------------|-------------|-------------------------|----------------------|
| `THREAD_LOCAL_FIXED` | â˜…â˜…â˜…â˜…â˜…       | Perfect                 | Production First Choice (Highest Performance) |
| `THREAD_ID_HASH`     | â˜…â˜…â˜…â˜…â˜…       | Perfect                 | More stable when thread count varies dynamically |
| `XOR_SHIFT_RANDOM`   | â˜…â˜…â˜…â˜…        | Excellent               | Requires random distribution |
| `THREAD_LOCAL_ROUND_ROBIN` | â˜…â˜…â˜… | Perfect                 | Single thread requires uniform distribution |

### Custom Configuration

#### **1. Fully Custom Configuration for EachId**
```java
EachId eachId = new EachId()
        .setTimestampBits(35)        // 35-bit timestamp, ~109 years validity (100ms step)
        .setWorkerIdBits(6)          // 6-bit WorkerId, 64 nodes
        .setSequenceBits(22)         // 22-bit sequence, 4.19M IDs/100ms
        .setStepMs(100)              // 100ms timestamp step
        .setEpoch("2025-01-01")      // Custom epoch
        .setClockBackwardThresholdMs(1000)  // 1-second clock backward tolerance: rollbacks under 1 second are ignored, IDs continue to be issued.
        .autoWorkerId();             // Automatically assign WorkerId or manually set via `.setWorkerId(n)`
```
```java
System.out.println(eachId.getInfo()); // Print configuration info

Console displays configuration info (valid years, theoretical capacity, etc.):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EachId Config
Epoch           : 2025-01-01
StepMs          : 100 ms
Bits            : 35(ts)+0(dc)+6(wk)+22(seq)=63 bits
Timestamp Range : 34,359,738,367 steps Ã— 100 ms = ~108 years 348 days
Capacity        : 64 nodes | 4,194,304 IDs/100ms (â‰ˆ41,943,040 IDs/sec theoretical)
WorkerId        : 1 (max 63)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

#### **2. Fully Custom Configuration for EachIdGroup**
```java
EachIdGroup group = new EachIdGroup()
        .setTimestampBits(35)        // 35-bit timestamp
        .setDatacenterIdBits(0)      // 0-bit datacenter
        .setWorkerIdBits(8)          // 8-bit WorkerId, 256 nodes
        .setSequenceBits(20)         // 20-bit sequence, 1.04M IDs/100ms
        .setStartWorkerIdAndCount(10, 4)  // WorkerId starts from 10, total 4 instances
        .setStepMs(100)              // 100ms timestamp step
        .setClockBackwardThresholdMs(1000)  // 1-second clock backward tolerance
        .setBalancingStrategy(EachIdGroup.BalancingStrategy.THREAD_LOCAL_ROUND_ROBIN);
```

## Author's Note
```
    I've reviewed many Snowflake variants and deeply studied Leaf, UidGenerator, TinyId.
    Ultimately, I found: true high performance doesn't come from CAS, RingBuffer, but from minimizing contention.
```

```
    Custom sharding + variable timestamp bits/step + variable sequence bits + batch acquisition support = EachId v2
    EachId v2 is my ultimate answer to distributed ID generators.
```

GitHub: [EachId](https://github.com/carlos-suen/eachid)  
Author: Carlos Suen  
Date: 2025

## ðŸ“„ License

This project is licensed under the **MIT License**. You are free to use, modify, and commercialize it in almost any scenario.

**Â© 2024-Present [Carlos Suen](https://github.com/carlos-suen)**

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)

> For detailed license terms, see the [LICENSE](LICENSE) file in the project root directory.

---

<div align="center">

**EachId** - High-Performance Distributed ID Generation Solution

[Report Issue](https://github.com/eachid/eachid/issues) Â· [Request Feature](https://github.com/eachid/eachid/issues) Â· [Contribute Code](https://github.com/eachid/eachid/pulls)

</div>

---
